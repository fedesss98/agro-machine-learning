#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
Created on Thu Jun 16 06:09:34 2022

@author: Federico Amato
Take ETa predicted and computes Kc by taking the ratio ETa/ET0.
This gives Kc*Ks.
Ks threshold is at average soil humidity < 0.21, for bigger values this is 1.

Predictions in folder:
PAPER/RESULTS/PREDICTIONS/
are generated by the code:
PAPER/ETA_NEWFEATURES/ETa_total_prediction.py

"""
import copy
import matplotlib.pyplot as plt
import numpy as np
import pandas as pd
import seaborn as sns

import MODULES.et_functions as et


# %% FUNCTIONS
def get_eta_predicted():
    database = (f'{ROOT}PAPER/RESULTS/PREDICTIONS/'
                f'eta_total_prediction_m{m}_{predictor}.csv')
    eta = pd.read_csv(database,
                      sep=';',
                      index_col=0,
                      parse_dates=True,
                      infer_datetime_format=True)

    return eta


def get_et_measures(database):
    eta = et.make_dataframe(
        database,
        date_format='%Y-%m-%d',
        columns=['ETa'],
        start='2018-01-01',
        end='2021-11-30',
        method='drop',
        drop_index=True,
        )

    eto = et.make_dataframe(
        database,
        date_format='%Y-%m-%d',
        columns=['ETo'],
        start='2018-01-01',
        end='2021-11-30',
        method='impute',
        nn=5,
        drop_index=True,
        )
    return eta, eto


def plot_kc(data, x, y, hue, theoretical=False, **kwargs):
    fig, ax = plt.subplots(figsize=(11, 5))
    # x = data[x].values
    source = data[hue].unique()
    colors = ['black', 'red']
    facecolors = ['black', 'none']
    for i in range(2):
        x_plot = data.query(f"source == '{source[i]}'")[x]
        y_plot = data.query(f"source == '{source[i]}'")[y]
        c = colors[i]
        face = facecolors[i]
        ax.scatter(x_plot, y_plot,
                   color=c, facecolors=face, marker='o', s=10,
                   label=source[i])
    if theoretical:
        ax = plot_trapezoidal(ax)
    ax.legend(loc='upper left')
    title = 'Kc Measured and Predicted'
    title = kwargs.get('title') if 'title' in kwargs else title
    xlabel = kwargs.get('xlabel') if 'xlabel' in kwargs else x
    ylabel = kwargs.get('ylabel') if 'ylabel' in kwargs else y
    if 'ylim' in kwargs:
        ylim = kwargs.get('ylim')
        ax.set_ylim(ylim)
    ax.set_title(title)
    ax.set_xlabel(xlabel, fontsize=26)
    ax.set_ylabel('$K_c \dot K_s$', fontsize=26)
    ax.tick_params(axis='x', labelrotation=90)
    plt.xticks(fontsize=18)
    plt.yticks(fontsize=18)
    return fig, ax


def get_trapezoidal():
    database = '../../CSV/KC/Trapezoidal_Kc.csv'
    kc = pd.read_csv(database,
                     sep=';',
                     decimal=',',
                     header=[1],
                     index_col=0,
                     parse_dates=True,
                     infer_datetime_format=True, dayfirst=True
                     )
    # kc = kc.loc[:'2021-11-30']
    return kc


def plot_trapezoidal(ax, **kwargs):
    kc = get_trapezoidal()
    x = kc.index
    allen = kc.iloc[:, 0]
    rallo = kc.iloc[:, 1]

    ax.plot(x, allen, 'b--', label=allen.name, linewidth=2)
    ax.plot(x, rallo, 'b-', label=rallo.name, linewidth=2)
    return ax


def plot_relplot(df, title):
    g = sns.relplot(
        data=df,
        x="Day",
        y="ETa",
        hue="source",
        style="source",
        height=5,
        aspect=1.61,
        ).set(title=title)
    plt.show()
    return g


def save_plot(figname):
    fname = f'{ROOT}/PAPER/RESULTS/RESULTS_AP/{figname}'
    plt.savefig(f'{fname}.png')
    plt.savefig(f'{fname}.pdf')
    plt.savefig(f'{fname}.eps')


def make_total_df(df, idx_measured):
    df['source'] = [
        'Measured' if i in idx_measured
        else 'Predicted'
        for i in df.index]
    df.index.name = 'Day'
    return df

# %% CONSTANTS


ROOT = '../../'
DATABASE = '../../CSV/db_villabate_deficit_6.csv'

END_DATE = None

MODELS = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12]
PREDICTORS = ['mlp', 'rf']

PLOT_ETA = False
SAVE = True

num_outliers = [{'mlp': 0, 'rf': 0} for i in MODELS]

# %% MAIN
# Get ETa and ET0 measured
eta, eto = get_et_measures(DATABASE)

for i, m in enumerate(MODELS):
    for predictor in PREDICTORS:
        eta_predict = get_eta_predicted()
        # Remove predictions where there are measures
        eta_predict = eta_predict.loc[[idx for idx in eto.index
                                       if idx not in eta.index]]
        print(f"Model {m} shapes:"
              f"\nETa: {eta.shape}"
              f"\nETo: {eto.shape}"
              f"\nETa Predicted: {eta_predict.shape}")

        # Make total ETa DataFrame (measures + predictions)
        total_eta = pd.concat([eta_predict, eta])
        # Computes total Kc (from measures and predictions)
        total_kc = total_eta['ETa'] / eto['ETo']
        total_kc = total_kc.to_frame('Kc')

        # %% PLOT ETa
        if PLOT_ETA:
            total_eta = make_total_df(total_eta, eta.index)
            plot_relplot(total_eta, title=f"ETa - Model {m}")

        # %% PLOT KC

        total_kc = make_total_df(total_kc, eta.index)
        plot_kc(total_kc.reset_index(),
                x="Day",
                y="Kc",
                hue="source",
                title=f"Kc Measured and Predicted for Model {m}",
                theoretical=True,
                ylim=(0, 2.8))
        plt.show()

        # Outliers detection
        outliers = et.remove_outliers(total_kc.loc[eta.index, 'Kc'],
                                      total_kc['Kc'],
                                      'IsolationForest',
                                      origin='Series',
                                      contamination=0.01,
                                      verbose=True)
        num_outliers[i][predictor] = np.count_nonzero(outliers)/len(total_kc)
        polish_kc = total_kc[~outliers]
        plot_kc(polish_kc.reset_index(),
                x="Day",
                y="Kc",
                hue="source",
                title=f"Kc Polished for Model {m}",
                theoretical=True,
                ylim=(0, 1.8))
        if SAVE:
            figname = f""
            save_plot()

        plt.show()

        # %% SAVE
        if SAVE:
            total_kc.to_csv(f"{ROOT}PAPER/RESULTS/CROPCOEFFICIENT_PREDICTIONS/"
                            f"kc_prediction_m{m}_{predictor}.csv",
                            sep=';')

print("Fraction of outliers removed:")
print(pd.DataFrame(num_outliers))
